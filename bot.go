package main

import (
	"database/sql"
	"fmt"
	"log"
	"nevolution/dab"
	"os"
	"os/signal"
	"strings"

	"github.com/BurntSushi/toml"
	"github.com/bwmarrin/discordgo"
)

type Init struct {
	Token   string
	GuildID string
}

var info Init
var d dab.Database
var allMutations map[string]struct{}

func init() {
	f := "setup_secret.toml"
	if _, err := os.Stat(f); err != nil {
		log.Fatal(err)
	}
	if _, err := toml.DecodeFile(f, &info); err != nil {
		log.Fatal(err)
	}
	db, err := sql.Open("sqlite3", "nev.db")
	if err != nil {
		log.Fatal(err)
	}
	d = dab.Wrap(db)
	allMutations = make(map[string]struct{})
	allMutations["kill"] = struct{}{}
	allMutations["eat"] = struct{}{}
}

var dg *discordgo.Session

func biome(s *discordgo.Session, i *discordgo.InteractionCreate) {
	rows := strings.Split(i.MessageComponentData().CustomID, "|")
	d.AddBiome(rows[1], rows[2])
	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: fmt.Sprintf("–£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω –±–∏–æ–º %v —Ç–∏–ø–∞ %v", rows[1], rows[2]),
		},
	})
	if err != nil {
		log.Fatal(err)
	}
}
func mutation(s *discordgo.Session, i *discordgo.InteractionCreate) {
	rows := strings.Split(i.MessageComponentData().CustomID, "|")
	d.StartMutation(rows[1], rows[2])
	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: fmt.Sprintf("–ù–∞—á–∞—Ç–æ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –º—É—Ç–∞—Ü–∏–∏ %v –≤ –≥—Ä–∞–¥–µ %v", rows[2], rows[1]),
		},
	})
	if err != nil {
		log.Fatal(err)
	}
}
func mutButton(name string, mut string) (button discordgo.Button) {
	return discordgo.Button{
		Emoji: discordgo.ComponentEmoji{
			Name: "üß¨",
		},
		Label:    mut,
		Style:    discordgo.PrimaryButton,
		CustomID: "newm@|" + name + "|" + mut,
	}

}

var (
	commands = []*discordgo.ApplicationCommand{
		{
			Name:        "rollback",
			Description: "–æ—Ç–∫–∞—Ç—ã–≤–∞–µ—Ç",
		},
		{
			Name:        "turn",
			Description: "–¥–µ–ª–∞–µ—Ç —Ö–æ–¥",
		},
		{
			Name:        "meteor",
			Description: "–±—É–º –±–∞–±–∞—Ö",
		},
		{
			Name:        "add-grade",
			Description: "Command for adding grades",
			Options: []*discordgo.ApplicationCommandOption{

				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "grade_name",
					Description: "–ò–º—è –≥—Ä–∞–¥—ã",
					Required:    true,
				},
			},
		},
		{
			Name:        "add-biome",
			Description: "Command for adding biomes",
			Options: []*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "biome_name",
					Description: "–ù–∞–∑–≤–∞–Ω–∏–µ –±–∏–æ–º–∞",
					Required:    true,
				},
			},
		},
		{
			Name:        "grade-to-biome",
			Description: "Command for adding grades to biomes",
			Options: []*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "grade_name",
					Description: "–ù–∞–∑–≤–∞–Ω–∏–µ –≥—Ä–∞–¥—ã",
					Required:    true,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "biome_name",
					Description: "–ù–∞–∑–≤–∞–Ω–∏–µ –±–∏–æ–º–∞",
					Required:    true,
				},
			},
		},
		{
			Name:        "grade-info",
			Description: "Gives grade info",
			Options: []*discordgo.ApplicationCommandOption{
				{Type: discordgo.ApplicationCommandOptionString,
					Name:        "grade_name",
					Description: "–ù–∞–∑–≤–∞–Ω–∏–µ –≥—Ä–∞–¥—ã",
					Required:    true,
				},
			},
		},
		{
			Name:        "new-mutation",
			Description: "Command for adding mutations to grades",
			Options: []*discordgo.ApplicationCommandOption{
				{Type: discordgo.ApplicationCommandOptionString,
					Name:        "grade_name",
					Description: "–ù–∞–∑–≤–∞–Ω–∏–µ –≥—Ä–∞–¥—ã",
					Required:    true,
				},
			},
		},
	}
	commandHandlers = map[string]func(s *discordgo.Session, i *discordgo.InteractionCreate){
		"rollback": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			d.Rollback()
			s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: "# —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫–∞—á–µ–Ω–æ",
				},
			})
		},
		"add-grade": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			options := i.ApplicationCommandData().Options
			optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
			for _, opt := range options {
				optionMap[opt.Name] = opt
			}
			var b strings.Builder
			if option, ok := optionMap["grade_name"]; ok {
				status := d.AddGrade(option.StringValue())
				if status == 1 {
					b.WriteString("–£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≥—Ä–∞–¥–∞ ")
				}
				b.WriteString(status.Text(option.StringValue()))
			}
			s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: b.String(),
				},
			})
		},
		"add-biome": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			options := i.ApplicationCommandData().Options
			optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
			for _, opt := range options {
				optionMap[opt.Name] = opt
			}
			if biome, ok := optionMap["biome_name"]; ok {
				status := d.CheckIfBiomeExists(biome.StringValue())
				if status == 2 {
					err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
						Type: discordgo.InteractionResponseChannelMessageWithSource,
						Data: &discordgo.InteractionResponseData{
							Content: fmt.Sprintf("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –±–∏–æ–º–∞ %v.", biome.StringValue()),
							Flags:   discordgo.MessageFlagsEphemeral,
							Components: []discordgo.MessageComponent{
								discordgo.ActionsRow{
									Components: []discordgo.MessageComponent{
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "‚ô®Ô∏è",
											},
											Label:    "–ì–µ–π–∑–µ—Ä—ã",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "geysers",
										},
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "üö¨",
											},
											Label:    "–ö—É—Ä–∏–ª—å—â–∏–∫–∏",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "smokers",
										},
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "üåä",
											},
											Label:    "–ü–µ–ª–∞–≥–∏–∞–ª—å",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "pelagial",
										},
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "üíß",
											},
											Label:    "–ü—Ä–µ—Å–Ω—ã–µ –≤–æ–¥—ã",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "freshwater",
										},
									},
								},
								discordgo.ActionsRow{
									Components: []discordgo.MessageComponent{
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "ü™®",
											},
											Label:    "–≠–Ω–¥–æ–ª–∏—Ç—ã",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "endolytes",
										},
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "‚òÅÔ∏è",
											},
											Label:    "–ê—Ç–º–æ—Å—Ñ–µ—Ä–∞",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "atmosphere",
										},
										discordgo.Button{
											Emoji: discordgo.ComponentEmoji{
												Name: "üåÄ",
											},
											Label:    "–õ–∏—Ç–æ—Ä–∞–ª—å",
											Style:    discordgo.PrimaryButton,
											CustomID: "newb@|" + biome.StringValue() + "|" + "littoral",
										},
									},
								},
							},
						},
					})
					if err != nil {
						log.Fatal(err)
					}
				}

			}
		},
		"grade-to-biome": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			options := i.ApplicationCommandData().Options
			optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
			for _, opt := range options {
				optionMap[opt.Name] = opt
			}
			var r strings.Builder
			if biome, ok := optionMap["biome_name"]; ok {
				status := d.CheckIfBiomeExists(biome.StringValue())
				if status == 2 {
					r.WriteString(fmt.Sprintf("–ë–∏–æ–º–∞ %v –Ω–µ—Ç.", biome.StringValue()))
				} else if status == 1 {
					if grade, ok := optionMap["grade_name"]; ok {
						status := d.AddGradeToBiome(biome.StringValue(), grade.StringValue())
						if status == 2 {
							r.WriteString(fmt.Sprintf("–ì—Ä–∞–¥—ã %v –Ω–µ—Ç.", grade.StringValue()))
						} else if status == 4 {
							r.WriteString(fmt.Sprintf("–ì—Ä–∞–¥–∞ %v —É–∂–µ –µ—Å—Ç—å –≤ –±–∏–æ–º–µ %v", grade.StringValue(), biome.StringValue()))
						} else if status == 1 {
							r.WriteString(fmt.Sprintf("–ì—Ä–∞–¥–∞ %v –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –±–∏–æ–º %v", grade.StringValue(), biome.StringValue()))
						}
					}
				}
			}
			s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: r.String(),
				},
			})
		},
		"meteor": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			d.Meteor()
			s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: "# –±–æ–º–±–∞–Ω—É–ª–æ",
				},
			})
		},
		"turn": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			d.Turn()
			s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: "# —Ö–æ–¥ —Å–¥–µ–ª–∞–Ω",
				},
			})
		},
		"grade-info": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			options := i.ApplicationCommandData().Options
			optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
			for _, opt := range options {
				optionMap[opt.Name] = opt
			}
			var r strings.Builder
			if name, ok := optionMap["grade_name"]; ok {
				str, status := d.GetGradeInto(name.StringValue())
				if status == 2 {
					r.WriteString(fmt.Sprintf("–ì—Ä–∞–¥—ã %v –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç", name.StringValue()))
				} else if status == 1 {
					r.WriteString(str)
				}
			}
			s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: r.String(),
				},
			})
		},
		"new-mutation": func(s *discordgo.Session, i *discordgo.InteractionCreate) {
			options := i.ApplicationCommandData().Options
			optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
			for _, opt := range options {
				optionMap[opt.Name] = opt
			}
			var absentMutations []string
			if option, ok := optionMap["grade_name"]; ok {
				b, status := d.GetGradeMutations(option.StringValue())
				if status == 1 {
					for key := range allMutations {
						if _, ok := b[key]; !ok {
							absentMutations = append(absentMutations, key)
						}
					}
					var cmp []discordgo.MessageComponent
					if len(absentMutations) > 5 {
						var overarchingArray [][]string
						c := (len(absentMutations) / 5) + 1
						for i := 0; i < len(absentMutations)-c; {
							overarchingArray = append(overarchingArray, absentMutations[i:i+c])
							i = i + c
						}
						for _, v := range overarchingArray {
							var comp []discordgo.MessageComponent
							for _, v2 := range v {
								comp = append(comp, mutButton(option.StringValue(), v2))
							}
							cmp = append(cmp, discordgo.ActionsRow{Components: comp})
						}
					} else {
						for _, v := range absentMutations {
							cmp = append(cmp, mutButton(option.StringValue(), v))
						}
					}
					err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
						Type: discordgo.InteractionResponseChannelMessageWithSource,
						Data: &discordgo.InteractionResponseData{
							Content: fmt.Sprintf("–±–ª—è–¥—å –ø–æ–≥–≥–ª—å —ç—Ç–æ –ø–µ–∑–¥–µ—Ü, –¥–≤–∞ —á–∞—Å–∞ –Ω–∞–¥ —ç—Ç–∏–º –∫–æ—Ä—á—É—Å—å. —ç–Ω–∏–≤–µ–π, —Å–ª–µ–¥—É—é—â–∏–µ –º—É—Ç–∞—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –≥—Ä–∞–¥—ã %v, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É", option.StringValue()),
							Flags:   discordgo.MessageFlagsEphemeral,
							Components: []discordgo.MessageComponent{
								discordgo.ActionsRow{
									Components: cmp,
								},
							},
						},
					})
					if err != nil {
						log.Fatal(err)
					}
				} else {
					s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
						Type: discordgo.InteractionResponseChannelMessageWithSource,
						Data: &discordgo.InteractionResponseData{
							Content: "–ø—Ä–æ–∏–∑–æ—à–ª–∞ –∫–∞–∫–∞—è-—Ç–æ —Ö—Ä–µ–Ω—å",
						},
					})
				}
			}
		},
	}
)

func init() {
	var err error
	dg, err = discordgo.New("Bot " + info.Token)
	if err != nil {
		log.Printf("error creating session %v", err)
		return
	}
}

func init() {
	dg.AddHandler(func(s *discordgo.Session, i *discordgo.InteractionCreate) {
		switch i.Type {
		case discordgo.InteractionApplicationCommand:
			if h, ok := commandHandlers[i.ApplicationCommandData().Name]; ok {
				h(s, i)
			}
		case discordgo.InteractionMessageComponent:
			if strings.Contains(i.MessageComponentData().CustomID, "|") && strings.Contains(i.MessageComponentData().CustomID, "newb@") {
				biome(s, i)
			} else if strings.Contains(i.MessageComponentData().CustomID, "|") && strings.Contains(i.MessageComponentData().CustomID, "newm@") {
				mutation(s, i)
			}
		}
	})
}

func main() {
	defer d.CloseDB()
	dg.Identify.Intents = discordgo.IntentsGuildMessages
	err := dg.Open()
	if err != nil {
		log.Fatal(err)
	}
	defer dg.Close()
	registeredCommands := make([]*discordgo.ApplicationCommand, len(commands))
	for i, v := range commands {
		cmd, err := dg.ApplicationCommandCreate(dg.State.User.ID, info.GuildID, v)
		if err != nil {
			log.Fatal(err)
		}
		registeredCommands[i] = cmd
	}
	if err != nil {
		log.Fatal(err)
		return
	}
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt)
	<-stop
	fmt.Println("removing commands...")
	for _, v := range registeredCommands {
		err := dg.ApplicationCommandDelete(dg.State.User.ID, info.GuildID, v.ID)
		if err != nil {
			log.Panicf("cannot delete '%v' command: %v", v.Name, err)
		}
	}
	fmt.Println("shutdown.")
}
